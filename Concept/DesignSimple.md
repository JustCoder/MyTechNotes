# 简单设计

---
## 简介

这三篇文章是我在搜索KISS概念方面的文章时找到的，主要说明简单设计的一些理念的，很巧的是，博主是我硕士课程的一位老师，在下只是组织了一下，没有任何原创或微原创的东西在里面。

---
## 摘要

1. *简单设计是一种只有极少数人能做出的设计，但设计一旦做出后，能被所有人理解*
1. *如果team得到了一个大多数人都理解的“简单”设计, 它是经验较少的人和经验较多的都会做出的, 那么要么是问题域本身很简单, 要么是所有人都没有真正理解问题域。当然也有可能是team应用了“简单设计”.*

---
## 简单设计

网上有很多关于简单设计的争论. 观察了一下发现大家其实在说两个问题：一个是作为结果的简单设计，一个是作为过程的简单设计. 说一下我的理解.

做为结果的简单设计是这么一种设计，它能被几乎所有人理解, 但只有极少数人能做出. 或者反过来说也可以. 简单设计是一种只有极少数人能做出的设计，但设计一旦做出后，能被所有人理解. 宏观物理世界这么复杂，但牛顿用三个定律就描述清楚. 质能方程E=MC2是另外一个例子. 如果这个定义是成立的, 那么可以有一个推论:

如果team得到了一个大多数人都理解的“简单”设计, 它是经验较少的人和经验较多的都会做出的, 那么要么是问题域本身很简单, 要么是所有人都没有真正理解问题域; 当然也有可能是team应用了后面将要说的作为过程的简单设计. 

做为结果的简单设计是很稀少的, 否则乔布斯, 牛顿和爱因斯坦也不会这么经典. 很多项目直到结束都未必得到一个简单的设计. 但所有项目都可以尝试的是作为过程的简单设计.

做为过程的简单设计是这么一种过程: 因为清楚的知道做为结果的简单设计是如此难以获得并深刻的理解难以获得的原因，从而以一种谦虚谨慎敬畏不妄加猜测的态度来做设计的一种过程, 同时又因为清楚的知道糟糕的设计是多么容易把项目引入复杂性的深渊从而始终保持一种警惕审慎以及艰苦卓绝的思考来时刻注视影响设计的因素是否发生变化以及时调整设计的过程.

一点都不简单.

---
## 简单 != 少

经常碰到的一段对话是：“这里为什么要引入一个类？字符串就好了，简单设计嘛” 或者 “一个switch/case就搞定的，弄个子类干嘛？”

事实通常是反过来的，引入新的类型或子类比使用字符串或switch/case更简单. 我来解释一下

设计是否简单的一个判断标准是它是否更容易理解. 而我们对事物的理解建立在概念或模型之上. 比如做一个最简单的超市存包系统，能存包能取包，没有进一步的需求. 牵扯到的概念可能有包裹，储物柜，存完包有个凭证用于取包. 这时我的设计中引入一个空类 public class Package {} 来代表包裹，另外一个空类 public class Ticket {} 来代表凭证. 你跟我说应该用字符串因为它更简单，反正也不会有新的需求, 我是不同意的. 我们来看采用这两种设计的代码，比如存包：

<pre>
<code>
public Ticket Put(Package package){…}
public string Put(string package) {…}
</code>
</pre>

用起来：

<pre>
<code>
new Cabinet().Put(new Package());
new Cabinet().Put(“some package”);
</code>
</pre>

即使不再有扩展需求，即使第一种设计比第二种设计多两个没有任何行为的空类，第一种设计也要比第二种简单. 因为它更易于理解. 它跟我脑袋里关于存包这件事概念和词汇是一致的，不需要做任何翻译的. 而采用字符串，我看到代码后还得把它翻译成包裹，翻译成凭证，甚至没人跟我解释这段代码我还不知道应该做个翻译，它阻碍了我的理解，因此它是更复杂的. 这是第一个角度*Ubiquitous Language**

第二个角度是沟通交流的问题. 我们在描述存包系统的需求的时候，不可避免的会提到包裹和凭证这类概念，Tester来写测试用例肯定也会用到这类词汇，可到代码中突然没有了，只剩字符串了, 你告诉我这是简单设计，你这是令人困惑的设计.

---
## 简单 != 可以有Bug

“这种错误情况先不用处理了吧, 简单设计嘛!”

简单不是偷懒的借口. 简单设计是一种宏观的设计策略, 并不意味着微观上的偷工减料:

* 你可以没有这个功能, 但有的话必须是不能出错的.
* 是对无法预知的需求推迟设计决定, 而不是对已知的需求视而不见
* 这种错误情况可能确实不需要现在处理, 但理由不应该是简单设计, 而是价值和优先级分析

---
## 简单 != 功能不完整

“这个功能先不用做了, 简单设计嘛!”

当听到这种说法的时候, 请确保团队的理解是一致的:

* 在产品设计上可能也会有”简单设计”之类的原则, 尽可能的简化功能, 突出主要卖点
* 但我们提到简单设计的时候, 更多的是指软件架构不要过度设计, 而不是功能.
* 最终这个功能可能确实不需要现在做, 但理由不应该是用于指导架构设计的”简单设计”, 而是价值和优先级分析.

---
## 简单设计 != 不预先设计

简单设计最大的争议在于: 现在还没有这个需求, 但我很清楚这是这个domain固有的问题, 我要不要为此做设计?

其实简单设计原则有一个隐含的前提: 架构是由需求决定的. 这可以是对的. 但它忽视了另外一个事实, 就是不只有一个架构, 不只有一种设计, 才能满足需求. 另外一个更有力的事实是: 可能存在一种基本的模型, 能适应不同的需求

如果你依靠对domain的洞察力, 可以设计出一种模型, 使得即使其考虑了尚未出现的需求, 也依然比现在的模型简单, 那何乐而不为?

争议在于模型复杂了怎么办? 那就按兵不动, 静观其变吧. 争议在于按兵不动日后再动的话可能成本更高. 这是有可能的, 我也不认为有什么算法可以算出此时该如何. 推荐大家看看< < Lean Architecture > >会有帮助

---
## 参考资料

* [Lightening Talk: 简单设计 ](http://blog.csdn.net/chelsea/article/details/6739002)
* [On Simple Design II](http://liguanglei.name/blogs/2012/05/22/on-simple-design-ii/)
* [On Simple Design III](http://liguanglei.name/blogs/2012/08/05/on-simple-design-iii/)
